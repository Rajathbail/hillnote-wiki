{"version":3,"sources":["../src/lib/documents-server.js","../src/lib/seo-utils.js","../src/routes/sitemap.js","../src/routes/robots.js","../src/routes/ai-sitemap.js","../src/routes/doc-index.js"],"sourcesContent":["import fs from 'fs'\nimport path from 'path'\nimport matter from 'gray-matter'\n// Note: siteConfig should be passed as a parameter instead of imported\nimport { pathToSlug } from './slug-utils'\n\n// Get the public directory path\nconst publicDir = path.join(process.cwd(), 'public')\n\n// Get all documents from the registry\nexport async function getDocumentRegistry(siteConfig) {\n  try {\n    const registryPath = path.join(\n      publicDir,\n      siteConfig.workspace.path,\n      siteConfig.workspace.registryFile\n    )\n    \n    const registryContent = fs.readFileSync(registryPath, 'utf8')\n    return JSON.parse(registryContent)\n  } catch (error) {\n    console.error('Error reading document registry:', error)\n    return { documents: [], folders: [] }\n  }\n}\n\n// Get all document paths for static generation\nexport async function getAllDocumentPaths(siteConfig) {\n  const registry = await getDocumentRegistry(siteConfig)\n  \n  return registry.documents?.map(doc => {\n    // Convert document path to URL slug\n    const slug = pathToSlug(doc.path)\n    const urlPath = slug.split('/')\n    \n    return {\n      params: {\n        path: urlPath\n      }\n    }\n  }) || []\n}\n\n// Find document by slug\nexport async function findDocumentBySlug(slugSegments, siteConfig) {\n  const registry = await getDocumentRegistry(siteConfig)\n  const targetSlug = slugSegments.join('/')\n  \n  // Find the document that matches this slug\n  const doc = registry.documents?.find(doc => {\n    const docSlug = pathToSlug(doc.path)\n    return docSlug === targetSlug\n  })\n  \n  if (!doc) return null\n  \n  // Return the actual path segments (without documents/ and .md)\n  return doc.path\n    .replace('documents/', '')\n    .replace('.md', '')\n    .split('/')\n}\n\n// Get document content by path\nexport async function getDocumentByPath(pathSegments, siteConfig) {\n  try {\n    // First try to find the document by slug\n    const actualPathSegments = await findDocumentBySlug(pathSegments, siteConfig)\n    \n    if (!actualPathSegments) {\n      // Fallback to direct path (for backwards compatibility)\n      const docPath = pathSegments.join('/')\n      const fullPath = path.join(\n        publicDir,\n        siteConfig.workspace.path,\n        'documents',\n        `${docPath}.md`\n      )\n      \n      if (!fs.existsSync(fullPath)) {\n        return null\n      }\n    }\n    \n    // Reconstruct the document path\n    const docPath = actualPathSegments ? actualPathSegments.join('/') : pathSegments.join('/')\n    const fullPath = path.join(\n      publicDir,\n      siteConfig.workspace.path,\n      'documents',\n      `${docPath}.md`\n    )\n    \n    // Check if file exists\n    if (!fs.existsSync(fullPath)) {\n      return null\n    }\n    \n    // Read the file content\n    const fileContent = fs.readFileSync(fullPath, 'utf8')\n    \n    // Parse frontmatter if it exists\n    const { data: frontmatter, content } = matter(fileContent)\n    \n    // Extract first paragraph for description\n    const firstParagraph = content\n      .split('\\n\\n')\n      .find(p => p.trim() && !p.startsWith('#'))\n      ?.replace(/[#*`]/g, '')\n      .trim()\n      .substring(0, 160)\n    \n    // Extract headings for structured data\n    const headings = []\n    const headingRegex = /^(#{1,6})\\s+(.+)$/gm\n    let match\n    while ((match = headingRegex.exec(content)) !== null) {\n      headings.push({\n        level: match[1].length,\n        text: match[2],\n        id: match[2].toLowerCase().replace(/[^\\w]+/g, '-')\n      })\n    }\n    \n    // Construct the full document path that matches the registry format\n    const fullDocPath = `documents/${actualPathSegments ? actualPathSegments.join('/') : docPath}.md`\n    \n    return {\n      path: fullDocPath,\n      title: frontmatter.title || pathSegments[pathSegments.length - 1].replace(/-/g, ' '),\n      description: frontmatter.description || firstParagraph || '',\n      content,\n      frontmatter,\n      headings,\n      lastModified: fs.statSync(fullPath).mtime.toISOString()\n    }\n  } catch (error) {\n    console.error('Error reading document:', error)\n    return null\n  }\n}\n\n// Generate breadcrumbs for a document path\nexport function generateBreadcrumbs(pathSegments) {\n  const breadcrumbs = [\n    { name: 'Home', path: '/' },\n    { name: 'Documentation', path: '/doc' }\n  ]\n  \n  let currentPath = '/doc'\n  pathSegments.forEach((segment, index) => {\n    currentPath += `/${segment}`\n    breadcrumbs.push({\n      name: segment.replace(/-/g, ' '),\n      path: currentPath,\n      isLast: index === pathSegments.length - 1\n    })\n  })\n  \n  return breadcrumbs\n}\n\n// Get related documents\nexport async function getRelatedDocuments(currentPath, siteConfig) {\n  const registry = await getDocumentRegistry(siteConfig)\n  \n  // Find documents in the same folder\n  const currentFolder = currentPath.split('/').slice(0, -1).join('/')\n  \n  const related = registry.documents\n    ?.filter(doc => {\n      const docFolder = doc.path.replace('documents/', '').split('/').slice(0, -1).join('/')\n      return docFolder === currentFolder && !doc.path.includes(currentPath)\n    })\n    .slice(0, 5)\n    .map(doc => ({\n      title: doc.path.split('/').pop()?.replace('.md', '').replace(/-/g, ' '),\n      path: `/doc/${doc.path.replace('documents/', '').replace('.md', '')}`\n    }))\n  \n  return related || []\n}","import { getDocumentRegistry } from './documents-server'\nimport { pathToSlug } from './slug-utils'\n\n/**\n * Generate sitemap entries for all documents\n * @param {string} baseUrl - The base URL of the site\n * @param {object} siteConfig - Site configuration object\n * @returns {Promise<Array>} Array of sitemap entries\n */\nexport async function generateSitemapEntries(baseUrl = 'https://example.com', siteConfig) {\n  const registry = await getDocumentRegistry(siteConfig)\n  \n  // Create sitemap entries for all documents\n  const documentEntries = registry.documents?.map(doc => {\n    // Use the same slug conversion as the routing\n    const slug = pathToSlug(doc.path)\n    \n    return {\n      url: `${baseUrl}/doc/${slug}`,\n      lastModified: new Date(),\n      changeFrequency: 'weekly',\n      priority: 0.8\n    }\n  }) || []\n  \n  // Add the homepage and doc index\n  const staticPages = [\n    {\n      url: baseUrl,\n      lastModified: new Date(),\n      changeFrequency: 'daily',\n      priority: 1.0\n    },\n    {\n      url: `${baseUrl}/doc`,\n      lastModified: new Date(),\n      changeFrequency: 'daily',\n      priority: 0.9\n    }\n  ]\n  \n  return [...staticPages, ...documentEntries]\n}\n\n/**\n * Generate robots.txt content\n * @param {string} baseUrl - The base URL of the site\n * @returns {string} Robots.txt content\n */\nexport function generateRobotsTxt(baseUrl = 'https://example.com') {\n  const hostname = baseUrl.replace(/^https?:\\/\\//, '')\n  \n  return `# Hillnote Wiki Documentation\n# AI-friendly structured data endpoint: ${baseUrl}/api/ai-sitemap\n# This endpoint provides JSON with document descriptions and relationships\n\nUser-Agent: *\nAllow: /\nAllow: /api/ai-sitemap\nDisallow: /api/\n\nUser-Agent: GPTBot\nAllow: /\nAllow: /api/ai-sitemap\n\nUser-Agent: ChatGPT-User\nAllow: /\nAllow: /api/ai-sitemap\n\nUser-Agent: CCBot\nAllow: /\nAllow: /api/ai-sitemap\n\nUser-Agent: Googlebot\nAllow: /\n\nUser-Agent: Bingbot\nAllow: /\n\n# Site information\nHost: ${hostname}\nSitemap: ${baseUrl}/sitemap.xml\n\n# For AI assistants: Access /api/ai-sitemap for structured document data\n# This endpoint provides:\n# - Document titles and descriptions\n# - Document relationships and references\n# - Navigation structure\n# - Last modified dates`\n}\n\n/**\n * Generate AI-friendly sitemap data\n * @param {string} baseUrl - The base URL of the site\n * @param {object} siteConfig - Site configuration object\n * @returns {Promise<object>} AI sitemap data\n */\nexport async function generateAISitemap(baseUrl = 'https://example.com', siteConfig = {}) {\n  const registry = await getDocumentRegistry(siteConfig)\n  \n  // Create a structured response for AI models\n  const aiSitemap = {\n    site: {\n      name: siteConfig.siteName || \"HillnoteWiki\",\n      description: siteConfig.siteDescription || \"Beautiful documentation with Next.js\",\n      baseUrl: baseUrl,\n    },\n    documents: registry.documents?.map(doc => {\n      const slug = pathToSlug(doc.path)\n      return {\n        title: doc.name,\n        url: `${baseUrl}/doc/${slug}`,\n        path: doc.path,\n        description: doc.description || `Documentation page: ${doc.name}`,\n        emoji: doc.emoji,\n        lastModified: doc.lastModified,\n        references: {\n          referencedIn: doc.referencedIn || [],\n          containsReferencesTo: doc.containsReferencesTo || []\n        },\n        type: doc.type\n      }\n    }) || [],\n    navigation: {\n      home: baseUrl,\n      documentation: `${baseUrl}/doc`,\n      aiSitemap: `${baseUrl}/api/ai-sitemap`,\n      standardSitemap: `${baseUrl}/sitemap.xml`\n    },\n    metadata: {\n      totalDocuments: registry.documents?.length || 0,\n      lastUpdated: new Date().toISOString(),\n      format: \"This endpoint provides structured JSON data optimized for AI crawlers and language models\"\n    }\n  }\n  \n  return aiSitemap\n}","import { generateSitemapEntries } from '../lib/seo-utils'\n\n/**\n * Next.js sitemap route handler\n * Usage: Export this from your app/sitemap.js file\n * \n * @example\n * // app/sitemap.js\n * export { default } from '@hillnote/wiki/routes/sitemap'\n */\nexport default async function sitemap() {\n  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'\n  \n  // Get the site config from environment or use defaults\n  const siteConfig = {\n    workspace: {\n      path: process.env.NEXT_PUBLIC_WORKSPACE_PATH || '/Welcome to Hillnote! /',\n      enabled: true,\n      documentsFolder: 'documents',\n      registryFile: 'documents-registry.json'\n    }\n  }\n  \n  return await generateSitemapEntries(baseUrl, siteConfig)\n}","import { generateRobotsTxt } from '../lib/seo-utils'\n\n/**\n * Next.js robots.txt route handler\n * Usage: Export this from your app/robots.txt/route.js file\n * \n * @example\n * // app/robots.txt/route.js\n * export { GET } from '@hillnote/wiki/routes/robots'\n */\nexport async function GET() {\n  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'\n  const robotsTxt = generateRobotsTxt(baseUrl)\n  \n  return new Response(robotsTxt, {\n    headers: {\n      'Content-Type': 'text/plain',\n    },\n  })\n}","import { generateAISitemap } from '../lib/seo-utils'\n\n/**\n * AI-friendly sitemap endpoint\n * Usage: Export this from your app/api/ai-sitemap/route.js file\n * \n * @example\n * // app/api/ai-sitemap/route.js\n * export { GET } from '@hillnote/wiki/routes/ai-sitemap'\n */\nexport async function GET() {\n  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'\n  \n  // Get the site config from environment or use defaults\n  const siteConfig = {\n    siteName: process.env.NEXT_PUBLIC_SITE_NAME || 'HillnoteWiki',\n    siteDescription: process.env.NEXT_PUBLIC_SITE_DESCRIPTION || 'Beautiful documentation with Next.js',\n    workspace: {\n      path: process.env.NEXT_PUBLIC_WORKSPACE_PATH || '/Welcome to Hillnote! /',\n      enabled: true,\n      documentsFolder: 'documents',\n      registryFile: 'documents-registry.json'\n    }\n  }\n  \n  const aiSitemap = await generateAISitemap(baseUrl, siteConfig)\n  \n  return Response.json(aiSitemap, {\n    headers: {\n      'Content-Type': 'application/json',\n      'Cache-Control': 'public, max-age=3600'\n    }\n  })\n}","import { redirect } from 'next/navigation'\nimport { getDocumentRegistry } from '../lib/documents-server'\nimport { pathToSlug } from '../lib/slug-utils'\n\n/**\n * Doc index page that redirects to the first document\n * Usage: Export this from your app/doc/page.js file\n * \n * @example\n * // app/doc/page.js\n * export { default } from '@hillnote/wiki/routes/doc-index'\n */\nexport default async function DocIndexPage() {\n  const siteConfig = {\n    workspace: {\n      path: process.env.NEXT_PUBLIC_WORKSPACE_PATH || '/Welcome to Hillnote! /',\n      enabled: true,\n      documentsFolder: 'documents',\n      registryFile: 'documents-registry.json',\n      initialFile: process.env.NEXT_PUBLIC_INITIAL_FILE || 'documents/Start Here .md'\n    }\n  }\n  \n  // Try to use the initial file from config first\n  if (siteConfig.workspace.initialFile) {\n    const slug = pathToSlug(siteConfig.workspace.initialFile)\n    redirect(`/doc/${slug}`)\n  }\n  \n  // Otherwise, get the first document from the registry\n  const registry = await getDocumentRegistry(siteConfig)\n  \n  if (registry.documents && registry.documents.length > 0) {\n    const firstDoc = registry.documents[0]\n    const slug = pathToSlug(firstDoc.path)\n    redirect(`/doc/${slug}`)\n  }\n  \n  // If no documents found, redirect to home\n  redirect('/')\n}"],"mappings":"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","names":["GET"]}